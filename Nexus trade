local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UIS = game:GetService("UserInputService")
local TS = game:GetService("TweenService")

-- RemoteEvents (el servidor debe crear/registrar estos RemoteEvents en ReplicatedStorage)
local actionRemote = ReplicatedStorage:WaitForChild("ActionRemote")
local responseRemote = ReplicatedStorage:WaitForChild("ActionResponse")

local gui = Instance.new("ScreenGui")
gui.ResetOnSpawn = false
gui.Name = "CoolUI"
gui.Parent = Players.LocalPlayer:WaitForChild("PlayerGui")
local main = Instance.new("Frame")
main.Size = UDim2.new(0, 200, 0, 160)
main.Position = UDim2.new(0.5, -100, 0.5, -80)
main.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
main.BorderSizePixel = 0
main.Parent = gui
Instance.new("UICorner", main).CornerRadius = UDim.new(0, 10)
local bg = Instance.new("UIGradient")
bg.Color = ColorSequence.new({
    ColorSequenceKeypoint.new(0, Color3.fromRGB(40, 40, 45)),
    ColorSequenceKeypoint.new(1, Color3.fromRGB(30, 30, 35))
})
bg.Parent = main
local shadow = Instance.new("ImageLabel")
shadow.Size = UDim2.new(1, 30, 1, 30)
shadow.Position = UDim2.new(0, -15, 0, -15)
shadow.BackgroundTransparency = 1
shadow.Image = "rbxassetid://297774371"
shadow.ImageColor3 = Color3.fromRGB(15, 15, 20)
shadow.ImageTransparency = 0.6
shadow.Parent = main
local label = Instance.new("TextLabel")
label.Size = UDim2.new(1, 0, 0, 30)
label.BackgroundTransparency = 1
label.Text = "Trade Scam"
label.TextColor3 = Color3.fromRGB(255, 255, 255)
label.TextSize = 16
label.Font = Enum.Font.GothamBold
label.Parent = main

-- Mantener referencias a toggles por feature para poder revertir visual si el servidor rechaza
local togglesByFeature = {}

local function makeToggle(text, yPos, featureName)
    local base = Instance.new("Frame")
    base.Size = UDim2.new(0.9, 0, 0, 30)
    base.Position = UDim2.new(0.5, 0, 0, yPos)
    base.BackgroundColor3 = Color3.fromRGB(40, 40, 45)
    base.BorderSizePixel = 0
    base.AnchorPoint = Vector2.new(0.5, 0)
    base.Parent = main
    Instance.new("UICorner", base).CornerRadius = UDim.new(0, 6)
    local btn = Instance.new("TextButton")
    btn.Size = UDim2.new(0, 40, 0, 20)
    btn.Position = UDim2.new(1, -45, 0.5, -10)
    btn.BackgroundColor3 = Color3.fromRGB(60, 60, 65)
    btn.BorderSizePixel = 0
    btn.Text = ""
    btn.Parent = base
    Instance.new("UICorner", btn).CornerRadius = UDim.new(1, 0)
    local dot = Instance.new("Frame")
    dot.Size = UDim2.new(0, 16, 0, 16)
    dot.Position = UDim2.new(0, 2, 0.5, -8)
    dot.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    dot.BorderSizePixel = 0
    dot.Parent = btn
    Instance.new("UICorner", dot).CornerRadius = UDim.new(1, 0)
    local txt = Instance.new("TextLabel")
    txt.Size = UDim2.new(1, -55, 1, 0)
    txt.Position = UDim2.new(0, 10, 0, 0)
    txt.BackgroundTransparency = 1
    txt.Text = text
    txt.TextColor3 = Color3.fromRGB(255, 255, 255)
    txt.TextSize = 14
    txt.Font = Enum.Font.Gotham
    txt.TextXAlignment = Enum.TextXAlignment.Left
    txt.Parent = base

    local on = false
    -- guardar referencias
    togglesByFeature[featureName] = {
        btn = btn,
        dot = dot,
        txt = txt,
        base = base,
        setState = function(state)
            local goals = {
                [btn] = {BackgroundColor3 = state and Color3.fromRGB(0, 170, 255) or Color3.fromRGB(60, 60, 65)},
                [dot] = {Position = state and UDim2.new(1, -18, 0.5, -8) or UDim2.new(0, 2, 0.5, -8)}
            }
            for obj, goal in pairs(goals) do
                TS:Create(obj, TweenInfo.new(0.2), goal):Play()
            end
            on = state
        end,
        getState = function() return on end
    }

    btn.MouseButton1Click:Connect(function()
        -- cambiar UI optimísticamente
        local newState = not on
        togglesByFeature[featureName].setState(newState)

        -- enviar petición real al servidor
        -- action: "ToggleFeature", featureName: string, value: boolean
        -- El servidor debe validar y responder por medio de ActionResponse
        actionRemote:FireServer("ToggleFeature", featureName, newState)
    end)

    -- escuchar respuesta para este feature: si el servidor rechaza, revertir UI
    responseRemote.OnClientEvent:Connect(function(feature, value, success, message)
        if feature ~= featureName then return end
        if success then
            -- servidor confirmó: dejar estado como viene en 'value'
            togglesByFeature[featureName].setState(value)
        else
            -- servidor rechazó: revertir visual al estado contrario de 'value' (o a 'not value')
            -- Nota: asumimos que 'value' es el intento enviado; revertimos
            local revertState = not value
            togglesByFeature[featureName].setState(revertState)
            warn(("Toggle '%s' rechazado por servidor: %s"):format(featureName, tostring(message)))
        end
    end)
end

-- Crear toggles con nombre de feature explícito para usar en RemoteEvent
makeToggle("Freeze Trade", 40, "FreezeTrade")
makeToggle("Auto Accept", 80, "AutoAccept")
makeToggle("Auto Add Items", 120, "AutoAddItems")

local drag = {
    enabled = false,
    start = nil,
    startPos = nil
}
main.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        drag.enabled = true
        drag.start = input.Position
        drag.startPos = main.Position

        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                drag.enabled = false
            end
        end)
    end
end)
UIS.InputChanged:Connect(function(input)
    if drag.enabled and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
        local delta = input.Position - drag.start
        main.Position = UDim2.new(
            drag.startPos.X.Scale,
            drag.startPos.X.Offset + delta.X,
            drag.startPos.Y.Scale,
            drag.startPos.Y.Offset + delta.Y
        )
    end
end)
